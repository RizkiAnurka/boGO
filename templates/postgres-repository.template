package postgres

import (
	"context"
	"fmt"

	"<module_name>/internal/domain/model"
	log "github.com/sirupsen/logrus"
	"gorm.io/gorm"
)

// <repo_name> represents the PostgreSQL repository for <entity_name> management
type <repo_name> struct {
	db *gorm.DB
}

// New<repo_name> creates a new instance of <repo_name>
func New<repo_name>(db *gorm.DB) *<repo_name> {
	return &<repo_name>{
		db: db,
	}
}

// Find retrieves <entity_name_plural> based on filter, sort, limit and offset parameters
func (repo *<repo_name>) Find(ctx context.Context, filter map[string]any, sort map[string]any, limit, offset int) (<entity_name_plural> []model.<struct_name>, total int64, err error) {
	counter := repo.db.Model(&model.<struct_name>{})
	// TODO: Apply filtering logic
	counter.Count(&total)

	result := repo.db.Limit(limit).Offset(offset)
	// TODO: Apply sorting and filtering
	result.Find(&<entity_name_plural>)
	err = result.Error
	return
}

// Create creates a new <entity_name>
func (repo *<repo_name>) Create(ctx context.Context, <entity_param> *model.<struct_name>) (err error) {
	result := repo.db.Create(&<entity_param>)
	if result.Error != nil {
		log.Error(result.Error)
		return result.Error
	}
	return nil
}

// Update updates an existing <entity_name>
func (repo *<repo_name>) Update(ctx context.Context, <entity_param> model.<struct_name>) (err error) {
	result := repo.db.Where("id = ?", <entity_param>.ID).Updates(&<entity_param>)
	if result.Error != nil {
		return result.Error
	}
	return nil
}

// Delete soft deletes a <entity_name> by ID
func (repo *<repo_name>) Delete(ctx context.Context, id int64) error {
	log.WithField("<entity_name>_id", id).Debug("Soft deleting <entity_name>")

	result := repo.db.WithContext(ctx).Model(&model.<struct_name>{}).
		Where("id = ? AND is_deleted = ?", id, false).
		Update("is_deleted", true)

	if result.Error != nil {
		log.WithError(result.Error).Error("Failed to soft delete <entity_name>")
		return fmt.Errorf("failed to delete <entity_name>: %w", result.Error)
	}

	if result.RowsAffected == 0 {
		return fmt.Errorf("<entity_name> with id %d not found or already deleted", id)
	}

	log.WithField("<entity_name>_id", id).Debug("Successfully soft deleted <entity_name>")
	return nil
}

// GetByID retrieves a <entity_name> by its ID
func (repo *<repo_name>) GetByID(ctx context.Context, id int64) (model.<struct_name>, error) {
	var <entity_param> model.<struct_name>
	result := repo.db.Where("id = ? AND is_deleted = ?", id, false).First(&<entity_param>)
	if result.Error != nil {
		return model.<struct_name>{}, result.Error
	}
	return <entity_param>, nil
}